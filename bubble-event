 src/axi.h:151
event metric (i = 0) {
 if (is_constant(cm)) {
    scalar * l = list_copy (all);
    cm = new scalar;
    free (all);
    all = list_concat ({cm}, l);
    free (l);
  }#if EMBED
  metric_embed_factor = axi_factor;
#endif
  scalar cmv = cm;
  foreach()
    cmv[] = y;
  cm[top] = dirichlet(y);
  cm[bottom] = dirichlet(y);
  if (is_constant(fm.x)) {
    scalar * l = list_copy (all);
    fm = new face vector;
    free (all);
    all = list_concat ((scalar *){fm}, l);
    free (l);
  }
  face vector fmv = fm;
  foreach_face()
    fmv.x[] = max(y, 1./HUGE);
  fm.t[top] = dirichlet(y);
  fm.t[bottom] = dirichlet(y);
#if TREE
  cm.refine = cm.prolongation = refine_cm_axi;
  fm.x.prolongation = refine_face_x_axi;
  fm.y.prolongation = refine_face_y_axi;
#endif
}
建立轴对称（axisymmetric）坐标系下的度量（metric），即将普通的笛卡尔网格“伪装”成轴对称柱坐标 (r,z)，其中 y 代表径向坐标 r。
这是 Basilisk 中实现轴对称模拟的经典写法（不开启真正的柱坐标，而是通过修改面通量和体积分的权重来模拟 2πr 的效果）。

./dissolve/embed-dissolve.h:906
event metric (i = 0)
{
  if (is_constant (fm.x)) {
    foreach_dimension()
      assert (constant (fm.x) == 1.);
    fm = fs;
  }
  foreach_face()
    fs.x[] = 1.;
  if (is_constant (cm)) {
    assert (constant (cm) == 1.);
    cm = cs;
  }
  foreach()
    cs[] = 1.;

#if TREE
  cs.refine = embed_fraction_refine;

  /**
  For prolongation we cannot use the same function since the surface
  fraction field *fs* is not necessarily defined for prolongation
  cells. So we switch back to the default fraction refinement (which
  is less accurate but only relies on *cs*). */

  // fixme: could work better with embed_fraction_refine
  // see porous1.tst
  cs.prolongation = fraction_refine;
  foreach_dimension()
    fs.x.prolongation = embed_face_fraction_refine_x;
  
  /**
  Note that we do not need to change the `refine` method since the
  default `refine` method calls the prolongation method for each
  component. */
  
#endif
  restriction ({cs, fs});
}
